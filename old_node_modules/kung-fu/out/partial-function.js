"use strict";
const option_1 = require('./option');
class PartialFunction {
    constructor(call) {
        this.call = call;
    }
    static empty() {
        return new PartialFunction((from) => option_1.Option.none());
    }
    static identity() {
        return new PartialFunction((t) => option_1.Option.some(t));
    }
    and(other) {
        return new PartialFunction((from) => this.call(from).caseOf({
            some: (to) => option_1.Option.some(to),
            none: () => other.call(from)
        }));
    }
    compose(other) {
        return new PartialFunction((from) => this.call(from).flatMap(to => other.call(to)));
    }
    map(f) {
        return new PartialFunction((from) => {
            return this.call(from).map(f);
        });
    }
    static concat(fs) {
        return fs.reduce((f, g) => f.and(g), PartialFunction.empty());
    }
    static asInstanceOf(con) {
        return new PartialFunction((from) => {
            if (from instanceof con) {
                return option_1.Option.some(from);
            }
            return option_1.Option.none();
        });
    }
}
exports.PartialFunction = PartialFunction;
//# sourceMappingURL=partial-function.js.map