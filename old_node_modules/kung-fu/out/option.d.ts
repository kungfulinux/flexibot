import { Either } from './either';
export declare type OptionPattern<T, X> = {
    none: () => X;
    some: (t: T) => X;
};
export declare class Option<T> {
    caseOf: <X>(pattern: OptionPattern<T, X>) => X;
    constructor(caseOf: <X>(pattern: OptionPattern<T, X>) => X);
    static some<T>(t: T): Option<T>;
    static empty: Option<any>;
    static none<T>(): Option<T>;
    static option<T>(f: () => T): Option<T>;
    isDefined(): boolean;
    isEmpty(): boolean;
    getOr(def: T): T;
    getOrLazy(def: () => T): T;
    get(): T;
    map<U>(f: (t: T) => U): Option<U>;
    map2<U, X>(other: Option<U>, f: (t: T, u: U) => X): Option<X>;
    flatMap<U>(f: (t: T) => Option<U>): Option<U>;
    filter(pred: (t: T) => boolean): Option<T>;
    truthy(): Option<T>;
    reduce<U>(f: (u: U, t: T) => U, init: U): U;
    orElse<U extends T>(other: Option<U>): Option<T>;
    orElseLazy<U extends T>(other: () => Option<U>): Option<T>;
    forEach(f: (t: T) => void): void;
    cata<U>(f: (t: T) => U, def: U): U;
    cataLazy<U>(f: (t: T) => U, def: () => U): U;
    toEither<L>(l: L): Either<L, T>;
    toArray(): Array<T>;
}
