"use strict";
const option_1 = require('./option');
class List {
    constructor(arr, begin, end) {
        this._arr = arr.slice(begin, end);
    }
    static empty() {
        return new List([]);
    }
    static singleton(t) {
        return new List([t]);
    }
    static fromArray(arr) {
        return new List(arr);
    }
    toArray() {
        return this._arr;
    }
    caseOf(pattern) {
        if (this._arr.length === 0) {
            return pattern.nil();
        }
        else {
            return pattern.cons(this._arr[0], new List(this._arr, 1));
        }
    }
    length() {
        return this._arr.length;
    }
    head() {
        return this.caseOf({
            nil: () => option_1.Option.none(),
            cons: (t, ts) => option_1.Option.some(t)
        });
    }
    tail() {
        return this.caseOf({
            nil: () => List.empty(),
            cons: (t, ts) => ts
        });
    }
    prepend(prev) {
        return new List([prev].concat(this._arr));
    }
    append(next) {
        return new List(this._arr.concat([next]));
    }
    concat(other) {
        return new List(this._arr.concat(other._arr));
    }
    foldLeft(step, init) {
        return this._arr.reduce((x, t) => step(x, t), init);
    }
    scanLeft(step, init) {
        return this._arr.reduce((xs, t) => xs.append(step(xs._arr[0], t)), List.singleton(init));
    }
    zip(other, f) {
        if (this.length > other.length) {
            return other.zip(this, (u, t) => f(t, u));
        }
        return new List(this._arr.map((t, idx) => f(t, other._arr[idx])));
    }
    map(f) {
        return new List(this._arr.map(f));
    }
    map2(other, f) {
        return this.flatMap(t => other.map(u => f(t, u)));
    }
    flatMap(f) {
        return this.map(f).foldLeft((xs, x) => xs.concat(x), List.empty());
    }
}
exports.List = List;
//# sourceMappingURL=list.js.map