"use strict";
const either_1 = require('./either');
class Option {
    constructor(caseOf) {
        this.caseOf = caseOf;
    }
    static some(t) {
        return new Option((pattern) => pattern.some(t));
    }
    static none() {
        return new Option((pattern) => pattern.none());
    }
    static option(f) {
        const val = f();
        return val ? Option.some(val) : Option.empty;
    }
    isDefined() {
        return this.caseOf({
            none: () => false,
            some: () => true
        });
    }
    isEmpty() {
        return this.caseOf({
            none: () => true,
            some: () => false
        });
    }
    getOr(def) {
        return this.caseOf({
            none: () => def,
            some: (t) => t
        });
    }
    getOrLazy(def) {
        return this.caseOf({
            none: () => def(),
            some: (t) => t
        });
    }
    get() {
        return this.caseOf({
            none: () => {
                throw new TypeError('option is empty');
            },
            some: (t) => t
        });
    }
    map(f) {
        return this.caseOf({
            none: () => Option.empty,
            some: (t) => Option.some(f(t))
        });
    }
    map2(other, f) {
        return this.caseOf({
            none: () => Option.empty,
            some: (t) => other.caseOf({
                none: () => Option.empty,
                some: (u) => Option.some(f(t, u))
            })
        });
    }
    flatMap(f) {
        return this.caseOf({
            none: () => Option.empty,
            some: (t) => f(t)
        });
    }
    filter(pred) {
        return this.caseOf({
            none: () => Option.empty,
            some: (t) => pred(t) ? this : Option.empty
        });
    }
    truthy() {
        return this.filter(v => !!v);
    }
    reduce(f, init) {
        return this.caseOf({
            none: () => init,
            some: (t) => f(init, t)
        });
    }
    orElse(other) {
        return this.caseOf({
            none: () => other,
            some: () => this
        });
    }
    orElseLazy(other) {
        return this.caseOf({
            none: () => other(),
            some: () => this
        });
    }
    forEach(f) {
        this.caseOf({
            none: () => { },
            some: (t) => f(t)
        });
    }
    cata(f, def) {
        return this.caseOf({
            none: () => def,
            some: (t) => f(t)
        });
    }
    cataLazy(f, def) {
        return this.caseOf({
            none: () => def(),
            some: (t) => f(t)
        });
    }
    toEither(l) {
        return this.caseOf({
            none: () => either_1.Either.left(l),
            some: (t) => either_1.Either.right(t)
        });
    }
    toArray() {
        return this.caseOf({
            none: () => [],
            some: (t) => [t]
        });
    }
}
Option.empty = Option.none();
exports.Option = Option;
//# sourceMappingURL=option.js.map