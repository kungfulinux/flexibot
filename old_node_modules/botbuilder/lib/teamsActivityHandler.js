"use strict";
/**
 * @module botbuilder
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const botbuilder_core_1 = require("botbuilder-core");
const teamsInfo_1 = require("./teamsInfo");
class TeamsActivityHandler extends botbuilder_core_1.ActivityHandler {
    /**
     * Invoked when an invoke activity is received from the connector.
     * Invoke activities can be used to communicate many different things.
     * @param context A context object for this turn.
     * @returns An Invoke Response for the activity.
     */
    onInvokeActivity(context) {
        const _super = Object.create(null, {
            onInvokeActivity: { get: () => super.onInvokeActivity }
        });
        return __awaiter(this, void 0, void 0, function* () {
            let runEvents = true;
            try {
                if (!context.activity.name && context.activity.channelId === 'msteams') {
                    return yield this.handleTeamsCardActionInvoke(context);
                }
                else {
                    switch (context.activity.name) {
                        case 'fileConsent/invoke':
                            return botbuilder_core_1.ActivityHandler.createInvokeResponse(yield this.handleTeamsFileConsent(context, context.activity.value));
                        case 'actionableMessage/executeAction':
                            yield this.handleTeamsO365ConnectorCardAction(context, context.activity.value);
                            return botbuilder_core_1.ActivityHandler.createInvokeResponse();
                        case 'composeExtension/queryLink':
                            return botbuilder_core_1.ActivityHandler.createInvokeResponse(yield this.handleTeamsAppBasedLinkQuery(context, context.activity.value));
                        case 'composeExtension/query':
                            return botbuilder_core_1.ActivityHandler.createInvokeResponse(yield this.handleTeamsMessagingExtensionQuery(context, context.activity.value));
                        case 'composeExtension/selectItem':
                            return botbuilder_core_1.ActivityHandler.createInvokeResponse(yield this.handleTeamsMessagingExtensionSelectItem(context, context.activity.value));
                        case 'composeExtension/submitAction':
                            return botbuilder_core_1.ActivityHandler.createInvokeResponse(yield this.handleTeamsMessagingExtensionSubmitActionDispatch(context, context.activity.value));
                        case 'composeExtension/fetchTask':
                            return botbuilder_core_1.ActivityHandler.createInvokeResponse(yield this.handleTeamsMessagingExtensionFetchTask(context, context.activity.value));
                        case 'composeExtension/querySettingUrl':
                            return botbuilder_core_1.ActivityHandler.createInvokeResponse(yield this.handleTeamsMessagingExtensionConfigurationQuerySettingUrl(context, context.activity.value));
                        case 'composeExtension/setting':
                            yield this.handleTeamsMessagingExtensionConfigurationSetting(context, context.activity.value);
                            return botbuilder_core_1.ActivityHandler.createInvokeResponse();
                        case 'composeExtension/onCardButtonClicked':
                            yield this.handleTeamsMessagingExtensionCardButtonClicked(context, context.activity.value);
                            return botbuilder_core_1.ActivityHandler.createInvokeResponse();
                        case 'task/fetch':
                            return botbuilder_core_1.ActivityHandler.createInvokeResponse(yield this.handleTeamsTaskModuleFetch(context, context.activity.value));
                        case 'task/submit':
                            return botbuilder_core_1.ActivityHandler.createInvokeResponse(yield this.handleTeamsTaskModuleSubmit(context, context.activity.value));
                        default:
                            runEvents = false;
                            return _super.onInvokeActivity.call(this, context);
                    }
                }
            }
            catch (err) {
                if (err.message === 'NotImplemented') {
                    return { status: 501 };
                }
                else if (err.message === 'BadRequest') {
                    return { status: 400 };
                }
                throw err;
            }
            finally {
                if (runEvents) {
                    this.defaultNextEvent(context)();
                }
            }
        });
    }
    /**
     * Handles a Teams Card Action Invoke activity.
     * @param context A context object for this turn.
     * @returns An Invoke Response for the activity.
     */
    handleTeamsCardActionInvoke(context) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('NotImplemented');
        });
    }
    /**
     * Receives invoke activities with Activity name of 'fileConsent/invoke'. Handlers registered here run before
     * `handleTeamsFileConsentAccept` and `handleTeamsFileConsentDecline`.
     * Developers are not passed a pointer to the next `handleTeamsFileConsent` handler because the _wrapper_ around
     * the handler will call `onDialogs` handlers after delegating to `handleTeamsFileConsentAccept` or `handleTeamsFileConsentDecline`.
     * @param context A context object for this turn.
     * @param fileConsentCardResponse Represents the value of the invoke activity sent when the user acts on a file consent card.
     * @returns A promise that represents the work queued.
     */
    handleTeamsFileConsent(context, fileConsentCardResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (fileConsentCardResponse.action) {
                case 'accept':
                    return yield this.handleTeamsFileConsentAccept(context, fileConsentCardResponse);
                case 'decline':
                    return yield this.handleTeamsFileConsentDecline(context, fileConsentCardResponse);
                default:
                    throw new Error('BadRequest');
            }
        });
    }
    /**
     * Receives invoke activities with Activity name of 'fileConsent/invoke' with confirmation from user
     * @remarks
     * This type of invoke activity occur during the File Consent flow.
     * @param context A context object for this turn.
     * @param fileConsentCardResponse Represents the value of the invoke activity sent when the user acts on a file consent card.
     * @returns A promise that represents the work queued.
     */
    handleTeamsFileConsentAccept(context, fileConsentCardResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('NotImplemented');
        });
    }
    /**
     * Receives invoke activities with Activity name of 'fileConsent/invoke' with decline from user
     * @remarks
     * This type of invoke activity occur during the File Consent flow.
     * @param context A context object for this turn.
     * @param fileConsentCardResponse Represents the value of the invoke activity sent when the user acts on a file consent card.
     * @returns A promise that represents the work queued.
     */
    handleTeamsFileConsentDecline(context, fileConsentCardResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('NotImplemented');
        });
    }
    /**
     * Receives invoke activities with Activity name of 'actionableMessage/executeAction'.
     * @param context A context object for this turn.
     * @param query The O365 connector card HttpPOST invoke query.
     * @returnsa A promise that represents the work queued.
     */
    handleTeamsO365ConnectorCardAction(context, query) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('NotImplemented');
        });
    }
    /**
     * Invoked when a signIn invoke activity is received from the connector.
     * @param context A context object for this turn.
     * @returns A promise that represents the work queued.
     */
    onSignInInvoke(context) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (context.activity.name) {
                case botbuilder_core_1.verifyStateOperationName:
                    return yield this.handleTeamsSigninVerifyState(context, context.activity.value);
                case botbuilder_core_1.tokenExchangeOperationName:
                    return yield this.handleTeamsSigninTokenExchange(context, context.activity.value);
            }
        });
    }
    /**
     * Receives invoke activities with Activity name of 'signin/verifyState'.
     * @param context A context object for this turn.
     * @param query Signin state (part of signin action auth flow) verification invoke query.
     * @returns A promise that represents the work queued.
     */
    handleTeamsSigninVerifyState(context, query) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('NotImplemented');
        });
    }
    /**
     * Receives invoke activities with Activity name of 'signin/tokenExchange'
     * @param context A context object for this turn.
     * @param query Signin state (part of signin action auth flow) verification invoke query
     * @returns A promise that represents the work queued.
     */
    handleTeamsSigninTokenExchange(context, query) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('NotImplemented');
        });
    }
    /**
     * Receives invoke activities with Activity name of 'composeExtension/onCardButtonClicked'
     * @param context A context object for this turn.
     * @param cardData Object representing the card data.
     * @returns A promise that represents the work queued.
     */
    handleTeamsMessagingExtensionCardButtonClicked(context, cardData) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('NotImplemented');
        });
    }
    /**
     * Receives invoke activities with Activity name of 'task/fetch'
     * @param context A context object for this turn.
     * @param taskModuleRequest The task module invoke request value payload.
     * @returns A Task Module Response for the request.
     */
    handleTeamsTaskModuleFetch(context, taskModuleRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('NotImplemented');
        });
    }
    /**
     * Receives invoke activities with Activity name of 'task/submit'
     * @param context A context object for this turn.
     * @param taskModuleRequest The task module invoke request value payload.
     * @returns A Task Module Response for the request.
     */
    handleTeamsTaskModuleSubmit(context, taskModuleRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('NotImplemented');
        });
    }
    /**
     * Receives invoke activities with Activity name of 'composeExtension/queryLink'
     * @remarks
     * Used in creating a Search-based Message Extension.
     * @param context A context object for this turn.
     * @param query he invoke request body type for app-based link query.
     * @returns The Messaging Extension Response for the query.
     */
    handleTeamsAppBasedLinkQuery(context, query) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('NotImplemented');
        });
    }
    /**
     * Receives invoke activities with the name 'composeExtension/query'.
     * @remarks
     * Used in creating a Search-based Message Extension.
     * @param context A context object for this turn.
     * @param query The query for the search command.
     * @returns The Messaging Extension Response for the query.
     */
    handleTeamsMessagingExtensionQuery(context, query) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('NotImplemented');
        });
    }
    /**
     * Receives invoke activities with the name 'composeExtension/selectItem'.
     * @remarks
     * Used in creating a Search-based Message Extension.
     * @param context A context object for this turn.
     * @param query he object representing the query.
     * @returns The Messaging Extension Response for the query.
     */
    handleTeamsMessagingExtensionSelectItem(context, query) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('NotImplemented');
        });
    }
    /**
     * Receives invoke activities with the name 'composeExtension/submitAction' and dispatches to botMessagePreview-flows as applicable.
     * @remarks
     * A handler registered through this method does not dispatch to the next handler (either `handleTeamsMessagingExtensionSubmitAction`, `handleTeamsMessagingExtensionBotMessagePreviewEdit`, or `handleTeamsMessagingExtensionBotMessagePreviewSend`).
     * This method exists for developers to optionally add more logic before the TeamsActivityHandler routes the activity to one of the
     * previously mentioned handlers.
     * @param context A context object for this turn.
     * @param action The messaging extension action.
     * @returns The Messaging Extension Action Response for the action.
     */
    handleTeamsMessagingExtensionSubmitActionDispatch(context, action) {
        return __awaiter(this, void 0, void 0, function* () {
            if (action.botMessagePreviewAction) {
                switch (action.botMessagePreviewAction) {
                    case 'edit':
                        return yield this.handleTeamsMessagingExtensionBotMessagePreviewEdit(context, action);
                    case 'send':
                        return yield this.handleTeamsMessagingExtensionBotMessagePreviewSend(context, action);
                    default:
                        throw new Error('BadRequest');
                }
            }
            else {
                return yield this.handleTeamsMessagingExtensionSubmitAction(context, action);
            }
        });
    }
    /**
     * Receives invoke activities with the name 'composeExtension/submitAction'.
     * @param context A context object for this turn.
     * @param action The messaging extension action.
     * @returns The Messaging Extension Action Response for the action.
     */
    handleTeamsMessagingExtensionSubmitAction(context, action) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('NotImplemented');
        });
    }
    /**
     * Receives invoke activities with the name 'composeExtension/submitAction' with the 'botMessagePreview' property present on activity.value.
     * The value for 'botMessagePreview' is 'edit'.
     * @param context A context object for this turn.
     * @param action The messaging extension action.
     * @returns The Messaging Extension Action Response for the action.
     */
    handleTeamsMessagingExtensionBotMessagePreviewEdit(context, action) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('NotImplemented');
        });
    }
    /**
     * Receives invoke activities with the name 'composeExtension/submitAction' with the 'botMessagePreview' property present on activity.value.
     * The value for 'botMessagePreview' is 'send'.
     * @param context A context object for this turn.
     * @param action The messaging extension action.
     * @returns The Messaging Extension Action Response for the action.
     */
    handleTeamsMessagingExtensionBotMessagePreviewSend(context, action) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('NotImplemented');
        });
    }
    /**
     * Receives invoke activities with the name 'composeExtension/fetchTask'
     * @param context A context object for this turn.
     * @param action The messaging extension action.
     * @returns The Messaging Extension Action Response for the action.
     */
    handleTeamsMessagingExtensionFetchTask(context, action) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('NotImplemented');
        });
    }
    /**
     * Receives invoke activities with the name 'composeExtension/querySettingUrl'
     * @param context A context object for this turn.
     * @param query The Messaging extension query.
     * @returns The Messaging Extension Action Response for the query.
     */
    handleTeamsMessagingExtensionConfigurationQuerySettingUrl(context, query) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('NotImplemented');
        });
    }
    /**
     * Receives invoke activities with the name 'composeExtension/setting'
     * @param context A context object for this turn.
     * @param settings Object representing the configuration settings.
     * @returns A promise that represents the work queued.
     */
    handleTeamsMessagingExtensionConfigurationSetting(context, settings) {
        throw new Error('NotImplemented');
    }
    /**
     * Override this method to change the dispatching of ConversationUpdate activities.
     * @param context A context object for this turn.
     * @returns A promise that represents the work queued.
     */
    dispatchConversationUpdateActivity(context) {
        const _super = Object.create(null, {
            dispatchConversationUpdateActivity: { get: () => super.dispatchConversationUpdateActivity }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handle(context, 'ConversationUpdate', () => __awaiter(this, void 0, void 0, function* () {
                if (context.activity.channelId == "msteams") {
                    const channelData = context.activity.channelData;
                    if (context.activity.membersAdded && context.activity.membersAdded.length > 0) {
                        return yield this.onTeamsMembersAdded(context);
                    }
                    if (context.activity.membersRemoved && context.activity.membersRemoved.length > 0) {
                        return yield this.onTeamsMembersRemoved(context);
                    }
                    if (!channelData || !channelData.eventType) {
                        return yield _super.dispatchConversationUpdateActivity.call(this, context);
                    }
                    switch (channelData.eventType) {
                        case 'channelCreated':
                            return yield this.onTeamsChannelCreated(context);
                        case 'channelDeleted':
                            return yield this.onTeamsChannelDeleted(context);
                        case 'channelRenamed':
                            return yield this.onTeamsChannelRenamed(context);
                        case 'teamArchived':
                            return yield this.onTeamsTeamArchived(context);
                        case 'teamDeleted':
                            return yield this.onTeamsTeamDeleted(context);
                        case 'teamHardDeleted':
                            return yield this.onTeamsTeamHardDeleted(context);
                        case 'channelRestored':
                            return yield this.onTeamsChannelRestored(context);
                        case 'teamRenamed':
                            return yield this.onTeamsTeamRenamed(context);
                        case 'teamRestored':
                            return yield this.onTeamsTeamRestored(context);
                        case 'teamUnarchived':
                            return yield this.onTeamsTeamUnarchived(context);
                        default:
                            return yield _super.dispatchConversationUpdateActivity.call(this, context);
                    }
                }
                else {
                    return yield _super.dispatchConversationUpdateActivity.call(this, context);
                }
            }));
        });
    }
    /**
     * Called in `dispatchConversationUpdateActivity()` to trigger the `'TeamsMembersAdded'` handlers.
     * @remarks
     * If no handlers are registered for the `'TeamsMembersAdded'` event, the `'MembersAdded'` handlers will run instead.
     * @param context A context object for this turn.
     * @returns A promise that represents the work queued.
     */
    onTeamsMembersAdded(context) {
        return __awaiter(this, void 0, void 0, function* () {
            if ('TeamsMembersAdded' in this.handlers && this.handlers['TeamsMembersAdded'].length > 0) {
                for (let i = 0; i < context.activity.membersAdded.length; i++) {
                    const channelAccount = context.activity.membersAdded[i];
                    // check whether we have a TeamChannelAccount, or the member is the bot
                    if ('givenName' in channelAccount ||
                        'surname' in channelAccount ||
                        'email' in channelAccount ||
                        'userPrincipalName' in channelAccount ||
                        context.activity.recipient.id === channelAccount.id) {
                        // we must have a TeamsChannelAccount, or a bot so skip to the next one
                        continue;
                    }
                    try {
                        context.activity.membersAdded[i] = yield teamsInfo_1.TeamsInfo.getMember(context, channelAccount.id);
                    }
                    catch (err) {
                        const errCode = err.body && err.body.error && err.body.error.code;
                        if (errCode === 'ConversationNotFound') {
                            // unable to find the member added in ConversationUpdate Activity in the response from the getMember call
                            const teamsChannelAccount = {
                                id: channelAccount.id,
                                name: channelAccount.name,
                                aadObjectId: channelAccount.aadObjectId,
                                role: channelAccount.role,
                            };
                            context.activity.membersAdded[i] = teamsChannelAccount;
                        }
                        else {
                            throw err;
                        }
                    }
                }
                yield this.handle(context, 'TeamsMembersAdded', this.defaultNextEvent(context));
            }
            else {
                yield this.handle(context, 'MembersAdded', this.defaultNextEvent(context));
            }
        });
    }
    /**
     * Called in `dispatchConversationUpdateActivity()` to trigger the `'TeamsMembersRemoved'` handlers.
     * @remarks
     * If no handlers are registered for the `'TeamsMembersRemoved'` event, the `'MembersRemoved'` handlers will run instead.
     * @param context A context object for this turn.
     * @returns A promise that represents the work queued.
     */
    onTeamsMembersRemoved(context) {
        return __awaiter(this, void 0, void 0, function* () {
            if ('TeamsMembersRemoved' in this.handlers && this.handlers['TeamsMembersRemoved'].length > 0) {
                yield this.handle(context, 'TeamsMembersRemoved', this.defaultNextEvent(context));
            }
            else {
                yield this.handle(context, 'MembersRemoved', this.defaultNextEvent(context));
            }
        });
    }
    /**
     * Invoked when a Channel Created event activity is received from the connector.
     * Channel Created correspond to the user creating a new channel.
     * @param context A context object for this turn.
     * @returns A promise that represents the work queued.
     */
    onTeamsChannelCreated(context) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handle(context, 'TeamsChannelCreated', this.defaultNextEvent(context));
        });
    }
    /**
     * Invoked when a Channel Deleted event activity is received from the connector.
     * Channel Deleted correspond to the user deleting a channel.
     * @param context A context object for this turn.
     * @returns A promise that represents the work queued.
     */
    onTeamsChannelDeleted(context) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handle(context, 'TeamsChannelDeleted', this.defaultNextEvent(context));
        });
    }
    /**
     * Invoked when a Channel Renamed event activity is received from the connector.
     * Channel Renamed correspond to the user renaming a new channel.
     * @param context A context object for this turn.
     * @returns A promise that represents the work queued.
     */
    onTeamsChannelRenamed(context) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handle(context, 'TeamsChannelRenamed', this.defaultNextEvent(context));
        });
    }
    /**
     * Invoked when a Team Archived event activity is received from the connector.
     * Team Archived correspond to the user archiving a team.
     * @param context The context for this turn.
     * @returns A promise that represents the work queued.
     */
    onTeamsTeamArchived(context) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handle(context, 'TeamsTeamArchived', this.defaultNextEvent(context));
        });
    }
    /**
     * Invoked when a Team Deleted event activity is received from the connector.
     * Team Deleted correspond to the user deleting a team.
     * @param context The context for this turn.
     * @returns A promise that represents the work queued.
     */
    onTeamsTeamDeleted(context) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handle(context, 'TeamsTeamDeleted', this.defaultNextEvent(context));
        });
    }
    /**
     * Invoked when a Team Hard Deleted event activity is received from the connector.
     * Team Hard Deleted correspond to the user hard-deleting a team.
     * @param context The context for this turn.
     * @returns A promise that represents the work queued.
     */
    onTeamsTeamHardDeleted(context) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handle(context, 'TeamsTeamHardDeleted', this.defaultNextEvent(context));
        });
    }
    /**
     *
     * @param context
     * Invoked when a Channel Restored event activity is received from the connector.
     * Channel Restored correspond to the user restoring a previously deleted channel.
     * @param context The context for this turn.
     * @returns A promise that represents the work queued.
     */
    onTeamsChannelRestored(context) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handle(context, 'TeamsChannelRestored', this.defaultNextEvent(context));
        });
    }
    /**
     * Invoked when a Team Renamed event activity is received from the connector.
     * Team Renamed correspond to the user renaming a team.
     * @param context The context for this turn.
     * @returns A promise that represents the work queued.
     */
    onTeamsTeamRenamed(context) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handle(context, 'TeamsTeamRenamed', this.defaultNextEvent(context));
        });
    }
    /**
     * Invoked when a Team Restored event activity is received from the connector.
     * Team Restored correspond to the user restoring a team.
     * @param context The context for this turn.
     * @returns A promise that represents the work queued.
     */
    onTeamsTeamRestored(context) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handle(context, 'TeamsTeamRestored', this.defaultNextEvent(context));
        });
    }
    /**
     * Invoked when a Team Unarchived event activity is received from the connector.
     * Team Unarchived correspond to the user unarchiving a team.
     * @param context The context for this turn.
     * @returns A promise that represents the work queued.
     */
    onTeamsTeamUnarchived(context) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handle(context, 'TeamsTeamUnarchived', this.defaultNextEvent(context));
        });
    }
    /**
     *
     * Override this in a derived class to provide logic for when members other than the bot
     * join the channel, such as your bot's welcome logic.
     * @param handler
     * @returns A promise that represents the work queued.
     */
    onTeamsMembersAddedEvent(handler) {
        return this.on('TeamsMembersAdded', (context, next) => __awaiter(this, void 0, void 0, function* () {
            const teamsChannelData = context.activity.channelData;
            yield handler(context.activity.membersAdded, teamsChannelData.team, context, next);
        }));
    }
    /**
     * Override this in a derived class to provide logic for when members other than the bot
     * leave the channel, such as your bot's good-bye logic.
     * @param handler
     * @returns A promise that represents the work queued.
     */
    onTeamsMembersRemovedEvent(handler) {
        return this.on('TeamsMembersRemoved', (context, next) => __awaiter(this, void 0, void 0, function* () {
            const teamsChannelData = context.activity.channelData;
            yield handler(context.activity.membersRemoved, teamsChannelData.team, context, next);
        }));
    }
    /**
     * Override this in a derived class to provide logic for when a channel is created.
     * @param handler
     * @returns A promise that represents the work queued.
     */
    onTeamsChannelCreatedEvent(handler) {
        return this.on('TeamsChannelCreated', (context, next) => __awaiter(this, void 0, void 0, function* () {
            const teamsChannelData = context.activity.channelData;
            yield handler(teamsChannelData.channel, teamsChannelData.team, context, next);
        }));
    }
    /**
     * Override this in a derived class to provide logic for when a channel is deleted.
     * @param handler
     * @returns A promise that represents the work queued.
     */
    onTeamsChannelDeletedEvent(handler) {
        return this.on('TeamsChannelDeleted', (context, next) => __awaiter(this, void 0, void 0, function* () {
            const teamsChannelData = context.activity.channelData;
            yield handler(teamsChannelData.channel, teamsChannelData.team, context, next);
        }));
    }
    /**
     * Override this in a derived class to provide logic for when a channel is renamed.
     * @param handler
     * @returns A promise that represents the work queued.
     */
    onTeamsChannelRenamedEvent(handler) {
        return this.on('TeamsChannelRenamed', (context, next) => __awaiter(this, void 0, void 0, function* () {
            const teamsChannelData = context.activity.channelData;
            yield handler(teamsChannelData.channel, teamsChannelData.team, context, next);
        }));
    }
    /**
     * Override this in a derived class to provide logic for when a team is archived.
     * @param handler
     * @returns A promise that represents the work queued.
     */
    onTeamsTeamArchivedEvent(handler) {
        return this.on('TeamsTeamArchived', (context, next) => __awaiter(this, void 0, void 0, function* () {
            const teamsChannelData = context.activity.channelData;
            yield handler(teamsChannelData.team, context, next);
        }));
    }
    /**
     * Override this in a derived class to provide logic for when a team is deleted.
     * @param handler
     * @returns A promise that represents the work queued.
     */
    onTeamsTeamDeletedEvent(handler) {
        return this.on('TeamsTeamDeleted', (context, next) => __awaiter(this, void 0, void 0, function* () {
            const teamsChannelData = context.activity.channelData;
            yield handler(teamsChannelData.team, context, next);
        }));
    }
    /**
     * Override this in a derived class to provide logic for when a team is hard-deleted.
     * @param handler
     * @returns A promise that represents the work queued.
     */
    onTeamsTeamHardDeletedEvent(handler) {
        return this.on('TeamsTeamHardDeleted', (context, next) => __awaiter(this, void 0, void 0, function* () {
            const teamsChannelData = context.activity.channelData;
            yield handler(teamsChannelData.team, context, next);
        }));
    }
    /**
     * Override this in a derived class to provide logic for when a channel is restored.
     * @param handler
     * @returns A promise that represents the work queued.
     */
    onTeamsChannelRestoredEvent(handler) {
        return this.on('TeamsChannelRestored', (context, next) => __awaiter(this, void 0, void 0, function* () {
            const teamsChannelData = context.activity.channelData;
            yield handler(teamsChannelData.channel, teamsChannelData.team, context, next);
        }));
    }
    /**
     * Override this in a derived class to provide logic for when a team is renamed.
     * @param handler
     * @returns A promise that represents the work queued.
     */
    onTeamsTeamRenamedEvent(handler) {
        return this.on('TeamsTeamRenamed', (context, next) => __awaiter(this, void 0, void 0, function* () {
            const teamsChannelData = context.activity.channelData;
            yield handler(teamsChannelData.team, context, next);
        }));
    }
    /**
     * Override this in a derived class to provide logic for when a team is restored.
     * @param handler
     * @returns A promise that represents the work queued.
     */
    onTeamsTeamRestoredEvent(handler) {
        return this.on('TeamsTeamRestored', (context, next) => __awaiter(this, void 0, void 0, function* () {
            const teamsChannelData = context.activity.channelData;
            yield handler(teamsChannelData.team, context, next);
        }));
    }
    /**
     * Override this in a derived class to provide logic for when a team is unarchived.
     * @param handler
     * @returns A promise that represents the work queued.
     */
    onTeamsTeamUnarchivedEvent(handler) {
        return this.on('TeamsTeamUnarchived', (context, next) => __awaiter(this, void 0, void 0, function* () {
            const teamsChannelData = context.activity.channelData;
            yield handler(teamsChannelData.team, context, next);
        }));
    }
}
exports.TeamsActivityHandler = TeamsActivityHandler;
//# sourceMappingURL=teamsActivityHandler.js.map