"use strict";
/**
 * @module botframework-streaming
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var headerSerializer_1 = require("../payloads/headerSerializer");
var payloadConstants_1 = require("../payloads/payloadConstants");
var transportDisconnectedEvent_1 = require("./transportDisconnectedEvent");
/**
 * Streaming payload sender.
 */
var PayloadSender = /** @class */ (function () {
    function PayloadSender() {
    }
    Object.defineProperty(PayloadSender.prototype, "isConnected", {
        /**
         * Tests whether the transport sender is connected.
         *
         * @returns true if connected to a transport sender.
         */
        get: function () {
            return !!this.sender;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Connects to the given transport sender.
     *
     * @param sender The transport sender to connect this payload sender to.
     */
    PayloadSender.prototype.connect = function (sender) {
        this.sender = sender;
    };
    /**
     * Sends a payload out over the connected transport sender.
     *
     * @param header The header to attach to the outgoing payload.
     * @param payload The stream of buffered data to send.
     * @param sentCalback The function to execute when the send has completed.
     */
    PayloadSender.prototype.sendPayload = function (header, payload, sentCallback) {
        var packet = { header: header, payload: payload, sentCallback: sentCallback };
        this.writePacket(packet);
    };
    /**
     * Disconnects this payload sender.
     *
     * @param e The disconnected event arguments to include in the disconnected event broadcast.
     */
    PayloadSender.prototype.disconnect = function (e) {
        if (this.isConnected) {
            this.sender.close();
            this.sender = null;
            if (this.disconnected) {
                this.disconnected(this, e || transportDisconnectedEvent_1.TransportDisconnectedEvent.Empty);
            }
        }
    };
    PayloadSender.prototype.writePacket = function (packet) {
        try {
            if (packet.header.payloadLength > 0 && packet.payload) {
                var leftOver = packet.header.payloadLength;
                while (leftOver > 0) {
                    var count = leftOver <= payloadConstants_1.PayloadConstants.MaxPayloadLength ? leftOver : payloadConstants_1.PayloadConstants.MaxPayloadLength;
                    var chunk = packet.payload.read(count);
                    var header = packet.header;
                    header.payloadLength = count;
                    header.end = leftOver <= payloadConstants_1.PayloadConstants.MaxPayloadLength;
                    var sendHeaderBuffer = Buffer.alloc(payloadConstants_1.PayloadConstants.MaxHeaderLength);
                    headerSerializer_1.HeaderSerializer.serialize(header, sendHeaderBuffer);
                    this.sender.send(sendHeaderBuffer);
                    this.sender.send(chunk);
                    leftOver -= chunk.length;
                }
                if (packet.sentCallback) {
                    packet.sentCallback();
                }
            }
        }
        catch (e) {
            this.disconnect(new transportDisconnectedEvent_1.TransportDisconnectedEvent(e.message));
        }
    };
    return PayloadSender;
}());
exports.PayloadSender = PayloadSender;
//# sourceMappingURL=payloadSender.js.map