"use strict";
/**
 * @module botbuilder-dialogs
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const botbuilder_core_1 = require("botbuilder-core");
const dialog_1 = require("./dialog");
const dialogEvents_1 = require("./dialogEvents");
const dialogSet_1 = require("./dialogSet");
const skillsHelpers_1 = require("./prompts/skillsHelpers");
function runDialog(dialog, context, accessor) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!dialog) {
            throw new Error('runDialog(): missing dialog');
        }
        if (!context) {
            throw new Error('runDialog(): missing context');
        }
        if (!context.activity) {
            throw new Error('runDialog(): missing context.activity');
        }
        if (!accessor) {
            throw new Error('runDialog(): missing accessor');
        }
        const dialogSet = new dialogSet_1.DialogSet(accessor);
        dialogSet.telemetryClient = dialog.telemetryClient;
        dialogSet.add(dialog);
        const dialogContext = yield dialogSet.createContext(context);
        const telemetryEventName = `runDialog(${dialog.constructor.name})`;
        // Handle EoC and Reprompt event from a parent bot (can be root bot to skill or skill to skill)
        if (isFromParentToSkill(context)) {
            // Handle remote cancellation request from parent.
            if (context.activity.type === botbuilder_core_1.ActivityTypes.EndOfConversation) {
                if (!dialogContext.stack.length) {
                    // No dialogs to cancel, just return.
                    return;
                }
                const activeDialogContext = getActiveDialogContext(dialogContext);
                const remoteCancelText = 'Skill was canceled through an EndOfConversation activity from the parent.';
                yield context.sendTraceActivity(telemetryEventName, undefined, undefined, `${remoteCancelText}`);
                // Send cancellation message to the top dialog in the stack to ensure all the parents are canceled in the right order. 
                yield activeDialogContext.cancelAllDialogs(true);
                return;
            }
            // Process a reprompt event sent from the parent.
            if (context.activity.type === botbuilder_core_1.ActivityTypes.Event && context.activity.name === dialogEvents_1.DialogEvents.repromptDialog) {
                if (!dialogContext.stack.length) {
                    // No dialogs to reprompt, just return.
                    return;
                }
                yield dialogContext.repromptDialog();
                return;
            }
        }
        // Continue or start the dialog.
        const result = yield dialogContext.continueDialog();
        if (result.status === dialog_1.DialogTurnStatus.empty) {
            yield dialogContext.beginDialog(dialog.id);
        }
        if (result.status === dialog_1.DialogTurnStatus.complete || result.status === dialog_1.DialogTurnStatus.cancelled) {
            if (shouldSendEndOfConversationToParent(context, result)) {
                const endMessageText = `Dialog ${dialog.id} has **completed**. Sending EndOfConversation.`;
                yield context.sendTraceActivity(telemetryEventName, result.result, undefined, `${endMessageText}`);
                // Send End of conversation at the end.
                const code = result.status == dialog_1.DialogTurnStatus.complete ? botbuilder_core_1.EndOfConversationCodes.CompletedSuccessfully : botbuilder_core_1.EndOfConversationCodes.UserCancelled;
                const activity = { type: botbuilder_core_1.ActivityTypes.EndOfConversation, value: result.result, locale: context.activity.locale, code: code };
                yield context.sendActivity(activity);
            }
        }
    });
}
exports.runDialog = runDialog;
/**
 * Helper to determine if we should send an EoC to the parent or not.
 * @param context
 */
function shouldSendEndOfConversationToParent(context, turnResult) {
    if (!(turnResult.status == dialog_1.DialogTurnStatus.complete || turnResult.status == dialog_1.DialogTurnStatus.cancelled)) {
        // The dialog is still going, don't return EoC.
        return false;
    }
    const claimIdentity = context.turnState.get(context.adapter.BotIdentityKey);
    // Inspect the cached ClaimsIdentity to determine if the bot was called from another bot.
    if (claimIdentity && skillsHelpers_1.isSkillClaim(claimIdentity.claims)) {
        // EoC Activities returned by skills are bounced back to the bot by SkillHandler.
        // In those cases we will have a SkillConversationReference instance in state.
        const skillConversationReference = context.turnState.get(botbuilder_core_1.SkillConversationReferenceKey);
        if (skillConversationReference) {
            // If the skillConversationReference.OAuthScope is for one of the supported channels, we are at the root and we should not send an EoC.
            return skillConversationReference.oAuthScope !== skillsHelpers_1.AuthConstants.ToBotFromChannelTokenIssuer && skillConversationReference.oAuthScope !== skillsHelpers_1.GovConstants.ToBotFromChannelTokenIssuer;
        }
        return true;
    }
    return false;
}
exports.shouldSendEndOfConversationToParent = shouldSendEndOfConversationToParent;
// Recursively walk up the DC stack to find the active DC.
function getActiveDialogContext(dialogContext) {
    const child = dialogContext.child;
    if (!child) {
        return dialogContext;
    }
    return getActiveDialogContext(child);
}
exports.getActiveDialogContext = getActiveDialogContext;
function isFromParentToSkill(context) {
    // If a SkillConversationReference exists, it was likely set by the SkillHandler and the bot is acting as a parent.
    if (context.turnState.get(botbuilder_core_1.SkillConversationReferenceKey)) {
        return false;
    }
    // Inspect the cached ClaimsIdentity to determine if the bot is acting as a skill.
    const identity = context.turnState.get(context.adapter.BotIdentityKey);
    return identity && skillsHelpers_1.isSkillClaim(identity.claims);
}
exports.isFromParentToSkill = isFromParentToSkill;
//# sourceMappingURL=dialogHelper.js.map