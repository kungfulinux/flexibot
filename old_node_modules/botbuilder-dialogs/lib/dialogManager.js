"use strict";
/**
 * @module botbuilder-dialogs
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const botbuilder_core_1 = require("botbuilder-core");
const dialogContext_1 = require("./dialogContext");
const dialog_1 = require("./dialog");
const configurable_1 = require("./configurable");
const dialogSet_1 = require("./dialogSet");
const memory_1 = require("./memory");
const dialogEvents_1 = require("./dialogEvents");
const dialogTurnStateConstants_1 = require("./dialogTurnStateConstants");
const skillsHelpers_1 = require("./prompts/skillsHelpers");
const dialogHelper_1 = require("./dialogHelper");
const LAST_ACCESS = '_lastAccess';
const CONVERSATION_STATE = 'ConversationState';
const USER_STATE = 'UserState';
class DialogManager extends configurable_1.Configurable {
    constructor(rootDialog, dialogStateProperty) {
        super();
        this._initialTurnState = new botbuilder_core_1.TurnContextStateCollection();
        /**
         * Global dialogs that you want to have be callable.
         */
        this.dialogs = new dialogSet_1.DialogSet();
        if (rootDialog) {
            this.rootDialog = rootDialog;
        }
        this._dialogStateProperty = dialogStateProperty || 'DialogStateProperty';
        this._initialTurnState.set(dialogTurnStateConstants_1.DialogTurnStateConstants.dialogManager, this);
    }
    /**
     * Values that will be copied to the `TurnContext.turnState` at the beginning of each turn.
     */
    get initialTurnState() {
        return this._initialTurnState;
    }
    /**
     * Root dialog to start from [onTurn()](#onturn) method.
     */
    set rootDialog(value) {
        this.dialogs = new dialogSet_1.DialogSet();
        if (value) {
            this._rootDialogId = value.id;
            this.dialogs.telemetryClient = value.telemetryClient;
            this.dialogs.add(value);
        }
        else {
            this._rootDialogId = undefined;
        }
    }
    get rootDialog() {
        return this._rootDialogId ? this.dialogs.find(this._rootDialogId) : undefined;
    }
    configure(config) {
        return super.configure(config);
    }
    onTurn(context) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure properly configured
            if (!this._rootDialogId) {
                throw new Error(`DialogManager.onTurn: the bot's 'rootDialog' has not been configured.`);
            }
            // Copy initial turn state to context
            this.initialTurnState.forEach((value, key) => {
                context.turnState.set(key, value);
            });
            const botStateSet = new botbuilder_core_1.BotStateSet();
            if (!this.conversationState) {
                this.conversationState = context.turnState.get(CONVERSATION_STATE);
            }
            else {
                context.turnState.set(CONVERSATION_STATE, this.conversationState);
            }
            if (!this.conversationState) {
                throw new Error(`DialogManager.onTurn: the bot's 'conversationState' has not been configured.`);
            }
            botStateSet.add(this.conversationState);
            if (!this.userState) {
                this.userState = context.turnState.get(USER_STATE);
            }
            else {
                context.turnState.set(USER_STATE, this.userState);
            }
            if (this.userState) {
                botStateSet.add(this.userState);
            }
            // Get last access
            const lastAccessProperty = this.conversationState.createProperty(LAST_ACCESS);
            const lastAccess = new Date(yield lastAccessProperty.get(context, new Date().toISOString()));
            // Check for expired conversation
            const now = new Date();
            if (this.expireAfter != undefined && (now.getTime() - lastAccess.getTime()) >= this.expireAfter) {
                // Clear conversation state
                yield this.conversationState.clear(context);
            }
            // Update last access time
            yield lastAccessProperty.set(context, lastAccess.toISOString());
            // get dialog stack 
            const dialogsProperty = this.conversationState.createProperty(this._dialogStateProperty);
            const dialogState = yield dialogsProperty.get(context, {});
            // Create DialogContext
            const dc = new dialogContext_1.DialogContext(this.dialogs, context, dialogState);
            // promote initial TurnState into dc.services for contextual services
            this._initialTurnState.forEach((value, key) => {
                dc.services.set(key, value);
            });
            // map TurnState into root dialog context.services
            context.turnState.forEach((value, key) => {
                dc.services.set(key, value);
            });
            // Configure dialog state manager and load scopes
            const dialogStateManager = new memory_1.DialogStateManager(dc, this.stateConfiguration);
            yield dialogStateManager.loadAllScopes();
            let turnResult;
            /**
             * Loop as long as we are getting valid onError handled we should continue executing the actions for the turn.
             * NOTE: We loop around this block because each pass through we either complete the turn and break out of the loop
             * or we have had an exception AND there was an onError action which captured the error. We need to continue the
             * turn based on the actions the onError handler introduced.
             */
            let endOfTurn = false;
            while (!endOfTurn) {
                try {
                    const claimIdentity = context.turnState.get(context.adapter.BotIdentityKey);
                    if (claimIdentity && skillsHelpers_1.isSkillClaim(claimIdentity.claims)) {
                        // The bot is running as a skill.
                        turnResult = yield this.handleSkillOnTurn(dc);
                    }
                    else {
                        // The bot is running as a root bot.
                        turnResult = yield this.handleBotOnTurn(dc);
                    }
                    // turn successfully completed, break the loop
                    endOfTurn = true;
                }
                catch (err) {
                    const handled = yield dc.emitEvent(dialogEvents_1.DialogEvents.error, err, true, true);
                    if (!handled) {
                        throw err;
                    }
                }
            }
            // Save any memory changes
            yield dialogStateManager.saveAllChanges();
            // Save BotState changes
            yield botStateSet.saveAllChanges(dc.context, false);
            return { turnResult: turnResult };
        });
    }
    // Helper to send a trace activity with a memory snapshot of the active dialog DC.
    sendStateSnapshotTrace(dc, traceLabel) {
        return __awaiter(this, void 0, void 0, function* () {
            // send trace of memory
            const snapshot = dialogHelper_1.getActiveDialogContext(dc).state.getMemorySnapshot();
            yield dc.context.sendActivity({
                type: botbuilder_core_1.ActivityTypes.Trace,
                name: 'BotState',
                valueType: 'https://www.botframework.com/schemas/botState',
                value: snapshot,
                label: traceLabel
            });
        });
    }
    handleSkillOnTurn(dc) {
        return __awaiter(this, void 0, void 0, function* () {
            // The bot is running as a skill.
            const turnContext = dc.context;
            // Process remote cancellation.
            if (turnContext.activity.type === botbuilder_core_1.ActivityTypes.EndOfConversation && dc.activeDialog && dialogHelper_1.isFromParentToSkill(turnContext)) {
                // Handle remote cancellation request from parent.
                const activeDialogContext = dialogHelper_1.getActiveDialogContext(dc);
                const remoteCancelText = 'Skill was canceled through an EndOfConversation activity from the parent.';
                yield turnContext.sendTraceActivity(`DialogManager.onTurn()`, undefined, undefined, remoteCancelText);
                // Send cancellation message to the top dialog in the stack to ensure all the parents are canceled in the right order. 
                return yield activeDialogContext.cancelAllDialogs(true);
            }
            // Handle reprompt
            // Process a reprompt event sent from the parent.
            if (turnContext.activity.type === botbuilder_core_1.ActivityTypes.Event && turnContext.activity.name == dialogEvents_1.DialogEvents.repromptDialog) {
                if (!dc.activeDialog) {
                    return { status: dialog_1.DialogTurnStatus.empty };
                }
                yield dc.repromptDialog();
                return { status: dialog_1.DialogTurnStatus.waiting };
            }
            // Continue execution
            // - This will apply any queued up interruptions and execute the current/next step(s).
            var turnResult = yield dc.continueDialog();
            if (turnResult.status == dialog_1.DialogTurnStatus.empty) {
                // restart root dialog
                var startMessageText = `Starting ${this._rootDialogId}.`;
                yield turnContext.sendTraceActivity('DialogManager.onTurn()', undefined, undefined, startMessageText);
                turnResult = yield dc.beginDialog(this._rootDialogId);
            }
            yield this.sendStateSnapshotTrace(dc, 'Skill State');
            if (dialogHelper_1.shouldSendEndOfConversationToParent(turnContext, turnResult)) {
                var endMessageText = `Dialog ${this._rootDialogId} has **completed**. Sending EndOfConversation.`;
                yield turnContext.sendTraceActivity('DialogManager.onTurn()', turnResult.result, undefined, endMessageText);
                // Send End of conversation at the end.
                const activity = { type: botbuilder_core_1.ActivityTypes.EndOfConversation, value: turnResult.result, locale: turnContext.activity.locale };
                yield turnContext.sendActivity(activity);
            }
            return turnResult;
        });
    }
    handleBotOnTurn(dc) {
        return __awaiter(this, void 0, void 0, function* () {
            let turnResult;
            // the bot is running as a root bot. 
            if (!dc.activeDialog) {
                // start root dialog
                turnResult = yield dc.beginDialog(this._rootDialogId);
            }
            else {
                // Continue execution
                // - This will apply any queued up interruptions and execute the current/next step(s).
                turnResult = yield dc.continueDialog();
                if (turnResult.status == dialog_1.DialogTurnStatus.empty) {
                    // restart root dialog
                    turnResult = yield dc.beginDialog(this._rootDialogId);
                }
            }
            yield this.sendStateSnapshotTrace(dc, 'Bot State');
            return turnResult;
        });
    }
}
exports.DialogManager = DialogManager;
//# sourceMappingURL=dialogManager.js.map