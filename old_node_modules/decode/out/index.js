"use strict";
const kung_fu_1 = require('kung-fu');
class DecodeError extends Error {
    constructor(message) {
        super();
        Error.captureStackTrace(this, 'DecodeError');
        this.name = 'DecodeError';
        this.message = message;
    }
}
exports.DecodeError = DecodeError;
class Decoder {
    constructor(_run) {
        this._run = _run;
    }
    decodeObject(data) {
        return this._run(data);
    }
    decodeString(data) {
        return this._run(JSON.parse(data));
    }
    map(f) {
        return new Decoder(data => f(this._run(data)));
    }
    andThen(f) {
        return new Decoder(data => f(this._run(data))._run(data));
    }
    reason(f) {
        return new Decoder(data => {
            try {
                return this._run(data);
            }
            catch (err) {
                if (err instanceof DecodeError) {
                    throw new DecodeError(f(err.message));
                }
                throw err;
            }
        });
    }
    static fail(message) {
        return new Decoder((data) => {
            throw new DecodeError(message);
        });
    }
    static succeed(value) {
        return new Decoder(data => value);
    }
    static get string() {
        return new Decoder(data => {
            if (data === null) {
                throw new DecodeError('data is null');
            }
            if (typeof data !== 'string') {
                throw new DecodeError('data is not a string');
            }
            return data;
        });
    }
    static get number() {
        return new Decoder(data => {
            if (data === null) {
                throw new DecodeError('data is null');
            }
            if (typeof data !== 'number') {
                throw new DecodeError('data is not a number');
            }
            return data;
        });
    }
    static get integer() {
        return Decoder.number.map(num => {
            if (!Number.isInteger(num)) {
                throw new DecodeError('data is not an integer');
            }
            return num;
        });
    }
    static get boolean() {
        return new Decoder(data => {
            if (data === null) {
                throw new DecodeError('data is null');
            }
            if (typeof data !== 'boolean') {
                throw new DecodeError('data is not a boolean');
            }
            return data;
        });
    }
    maybe() {
        return new Decoder(data => {
            if (data === null || typeof data === 'undefined') {
                return kung_fu_1.Option.none();
            }
            return kung_fu_1.Option.some(this._run(data));
        });
    }
    array() {
        return new Decoder(data => {
            if (!Array.isArray(data)) {
                throw new DecodeError('data is not an array');
            }
            return data.map((inner) => this._run(inner));
        });
    }
    at(path) {
        return new Decoder(data => {
            const inner = path.reduce((intermediate, pathComponent) => {
                return intermediate && intermediate[pathComponent];
            }, data);
            return this._run(inner);
        });
    }
    dict() {
        return new Decoder(data => {
            const map = {};
            Object.keys(data).forEach(key => {
                map[key] = this._run(data[key]);
            });
            return map;
        });
    }
    static oneOf(decoders) {
        return new Decoder(data => {
            let lastErr;
            for (let decoder of decoders) {
                try {
                    return decoder._run(data);
                }
                catch (err) {
                    lastErr = err;
                }
            }
            throw lastErr;
        });
    }
    static object2(a, b, f) {
        return new Decoder(data => {
            return f(a._run(data), b._run(data));
        });
    }
    static object3(a, b, c, f) {
        return new Decoder(data => {
            return f(a._run(data), b._run(data), c._run(data));
        });
    }
    static object4(a, b, c, d, f) {
        return new Decoder(data => {
            return f(a._run(data), b._run(data), c._run(data), d._run(data));
        });
    }
    static object5(a, b, c, d, e, f) {
        return new Decoder(data => {
            return f(a._run(data), b._run(data), c._run(data), d._run(data), e._run(data));
        });
    }
    static object6(a, b, c, d, e, f, x) {
        return new Decoder(data => {
            return x(a._run(data), b._run(data), c._run(data), d._run(data), e._run(data), f._run(data));
        });
    }
    static object7(a, b, c, d, e, f, g, x) {
        return new Decoder(data => {
            return x(a._run(data), b._run(data), c._run(data), d._run(data), e._run(data), f._run(data), g._run(data));
        });
    }
    static object8(a, b, c, d, e, f, g, h, x) {
        return new Decoder(data => {
            return x(a._run(data), b._run(data), c._run(data), d._run(data), e._run(data), f._run(data), g._run(data), h._run(data));
        });
    }
}
exports.Decoder = Decoder;
//# sourceMappingURL=index.js.map